# プロジェクトの意義

技術記事を収集し、読む習慣を少しでも効率化するためのプロジェクト。

# 解決策

技術記事をタブで開き、並べておくことが多い。
APIとDBを用意しておき、記事を保存できるようにする。
タブを複数選択して一括で記事とタイトルをAPIに送信する拡張機能を実装して、記事を保存する。
別途記事を読むためのUIを用意して運用を始める。

# ロードマップ

- [ ] Cloudflare workersでAPIとDBを用意
    - HonoとDrizzleを利用
- [ ] Chrome拡張機能を作成
    - [ ] タブを複数選択して一括で記事を保存
- [ ] 記事を読むためのUIを作成
    - [ ] 記事を一覧表示

# 設計

- API
    - HonoとDrizzleを利用
    - Biomeで静的解析
    - UnitテストはVitest
    - DIを意識した実装
- Chrome拡張機能
    - Javascriptで実装
    - テストしない
    - シンプルな選択中タブを固定で定義済みのAPIエンドポイントに送信する
    - ライブラリを利用しない
- UI
    - Nextjsで実装
    - Biomeで静的解析
    - UnitテストはVitest
    - Cloudfalre workersにデプロイ
- GitHub Actions
    - PR時にBiomeで静的解析
    - PR時にUnitテストを実行
    - depenabotで依存関係の更新を自動化

# ルール

- UIとAPIは単体テストを書きやすい設計を意識する
- 実装後は必ずディレクトリ内で`mpm run format`を実行しフォーマットする
- 実装後は必ずディレクトリ内で`mpm run test`を実行し静的解析を行う
- APIのテストカバレッジは90%以上を保つ
- 新規追加した仕様やメモは必ず、`.cline`以下に適切なファイル名のマークダウンを作成し記述する
- .cline以下の仕様を確認した上で実装を行うこと。

# Drizzleのスキーマ定義

SQLiteの構文が前提となる。以下は構文のサンプル。実装にはひきづらないこと。
```
import { sqliteTable, integer } from "drizzle-orm/sqlite-core"
export const users = sqliteTable('users', {
  id: integer()
});
```

SQLiteにはスキーマの概念がないので、単一のSQLiteファイルコンテキスト内でのみテーブルを定義できます。
```
import { sqliteTable as table } from "drizzle-orm/sqlite-core";
import * as t from "drizzle-orm/sqlite-core";
import { AnySQLiteColumn } from "drizzle-orm/sqlite-core";

export const users = table(
  "users",
  {
    id: t.int().primaryKey({ autoIncrement: true }),
    firstName: t.text("first_name"),
    lastName: t.text("last_name"),
    email: t.text().notNull(),
    invitee: t.int().references((): AnySQLiteColumn => users.id),
    role: t.text().$type<"guest" | "user" | "admin">().default("guest"),
  },
  (table) => [
    t.uniqueIndex("email_idx").on(table.email)
  ]
);

export const posts = table(
  "posts",
  {
    id: t.int().primaryKey({ autoIncrement: true }),
    slug: t.text().$default(() => generateUniqueString(16)),
    title: t.text(),
    ownerId: t.int("owner_id").references(() => users.id),
  },
  (table) => [
    t.uniqueIndex("slug_idx").on(table.slug),
    t.index("title_idx").on(table.title),
  ]
);

export const comments = table("comments", {
  id: t.int().primaryKey({ autoIncrement: true }),
  text: t.text({ length: 256 }),
  postId: t.int("post_id").references(() => posts.id),
  ownerId: t.int("owner_id").references(() => users.id),
});
```