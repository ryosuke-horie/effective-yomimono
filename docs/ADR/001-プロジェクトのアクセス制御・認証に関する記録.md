# プロジェクトのアクセス制御・認証に関する意思決定記録

## 日時
2025-04-07

## 背景
Effective Yomimonoは個人用読書管理ツールとして開発されており、UIとAPIがそれぞれCloudflare Workersにデプロイされている状態です。当初は以下の課題に直面していました：

1. **無料枠リソース消費の懸念**: 公開URLに対する意図しないアクセスやボットによるアクセスにより、Cloudflare Workersの無料枠が消費されるリスク
2. **個人用ツールの特性**: 本来は個人利用を目的としたアプリケーションであり、広く一般に公開する必要がない
3. **アーキテクチャ上の制約**: フロントエンドとバックエンドAPIが別々のCloudflare Workersドメインで運用されている構造

当初は単純なJWT認証などのアプリケーションレベルでの対応を検討していましたが、検討を進める中で「個人用ツールである」という特性を考慮し、より効果的な保護方法を模索するに至りました。

## 検討プロセス

検討は以下のプロセスで進みました：

1. **初期案: アプリケーションレベルの認証**
   - JWTベースの認証を導入
   - 環境変数で単一ユーザーの認証情報を管理
   
   → 課題: リクエストがWorkersに到達する時点ですでにリソースが消費される

2. **再検討: ネットワーク層での保護**
   - Cloudflareの機能を活用した多層防御
   - エッジレベルでのリクエストフィルタリング
   
   → 利点: リクエストがWorkersに到達する前に制御可能

3. **実装上の課題: クロスドメインの認証**
   - フロントエンドとAPIの分離構造での認証情報共有
   - ブラウザ拡張機能からのアクセス認証
   
   → 解決策: サービストークンによる統一的なアクセス制御

## 決定

**Cloudflare Accessを活用したネットワーク層でのアクセス制御を導入する**

具体的な実装内容：

1. **Cloudflare Accessの導入**
   - フロントエンドアプリケーション: ユーザー認証（Google、GitHubなど）
   - バックエンドAPI: サービストークンによる認証
   - 無料プラン（50ユーザーまで）で十分に対応可能

2. **サービストークンによるクロスドメイン認証**
   - Cloudflare Zero Trustダッシュボードでサービストークンを生成
   - フロントエンドとブラウザ拡張機能からのAPIリクエストで同一のトークンを使用
   - ヘッダーベースの認証（`CF-Access-Client-Id`と`CF-Access-Client-Secret`）

3. **多層防御の追加施策**
   - WAFルールとレート制限の設定
   - 地理的アクセス制限（主に利用する国や地域のみ許可）

## 根拠

この決定の主な根拠：

1. **リソース保護の効果**: ネットワーク層（Cloudflareエッジ）でリクエストをフィルタリングするため、Workersのリソース消費を効果的に防止できる
2. **個人用ツールの特性に合致**: 広く公開する必要がなく、認証されたアクセスのみを許可するアプローチが適切
3. **実装の実現性**: Cloudflareの既存機能を活用し、複雑なカスタム実装を避けられる
4. **コスト効率**: 無料プランで実現可能であり、追加費用が不要
5. **拡張性**: 将来的なニーズの変化にも対応しやすい基盤となる

## トレードオフ

この決定により、以下のトレードオフが生じます：

### メリット
- Cloudflare Workersの無料枠消費リスクが大幅に低減
- ボット、クローラー、悪意あるトラフィックからの保護
- 個人用ツールとしての適切なアクセス制限
- 複数の防御層による安全性の向上

### デメリット
- Cloudflareサービスへの依存度の増加
- サービストークンがクライアントサイドコードに含まれるセキュリティ上の懸念
  （個人利用の範囲では許容可能と判断）
- トークンローテーション時に複数コンポーネントの更新が必要

## 実装方針

1. **Cloudflare Accessのセットアップ**
   - Zero Trustアカウントの作成
   - アプリケーション登録とアクセスポリシー設定
   - サービストークンの生成

2. **フロントエンドの実装**
   ```javascript
   const API_BASE_URL = 'https://api-xyz.workers.dev';
   const CF_ACCESS_CLIENT_ID = process.env.CF_ACCESS_CLIENT_ID;
   const CF_ACCESS_CLIENT_SECRET = process.env.CF_ACCESS_CLIENT_SECRET;

   async function apiRequest(endpoint, method = 'GET', body = null) {
     const options = {
       method,
       headers: {
         'Content-Type': 'application/json',
         'CF-Access-Client-Id': CF_ACCESS_CLIENT_ID,
         'CF-Access-Client-Secret': CF_ACCESS_CLIENT_SECRET
       }
     };
     
     if (body) {
       options.body = JSON.stringify(body);
     }
     
     const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
     
     if (!response.ok) {
       throw new Error(`API request failed: ${response.status}`);
     }
     
     return response.json();
   }
   ```

3. **ブラウザ拡張機能の実装**
   - 同様のトークンベース認証を拡張機能に組み込み
   - APIリクエスト時に認証ヘッダーを付与

4. **セキュリティ強化対策**
   - 環境変数を使用したトークン管理
   - 定期的なトークンローテーション計画
   - WAFとレート制限の設定

## 結論

Effective Yomimonoの個人用ツールとしての特性を考慮し、Cloudflare Accessを中心としたネットワーク層でのアクセス制御が最適な選択肢であると判断しました。この方式により、Cloudflare Workersのリソース保護という主目的を達成しつつ、実装の複雑さとコストを最小限に抑えることができます。

今後の利用パターンや要件の変化に応じて、認証方式の見直しや強化を検討していくものとします。